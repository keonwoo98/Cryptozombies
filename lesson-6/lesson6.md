# **Cryptozombies[lesson6]**

> **크립토좀비로 솔리디티 공부하기** [링크](https://cryptozombies.io)

## **1. `Web3.js` 소개**

`lesson5`에서 좀비 `DApp`이 완성되었고 이제는 사용자들이 상호작용 할 수 있는 기본적인 웹 페이지를 만들 것이다. 이를 만들기 위해, 이더리움 재단에서 만든 자바스크립트 라이브러리인 `Web3.js`를 사용할 것이다.

### `Web3.js`란?

이더리움 네트워크는 노드로 구성되어 있고, 각 노드는 블록체인의 복사본을 가지고 있다. 누구든 스마트 컨트랙트의 함수를 실행하고자 한다면, 이 노드들 중 하나의 질의를 보내 아래 내용을 전달해야 한다 :

1. 스마트 컨트랙트 주소
2. 실행하고자 하는 함수, 그리고
3. 그 함수에 전달하고자 하는 변수들

이더리움 노드들은 `JSON-RPC`라고 불리는 언어로만 소통할 수 있고, 이는 사람이 읽기는 불편하다. 컨트랙트의 함수를 실행하고 싶다고 질의를 보내는 것은 다음과 같이 생겼다 :

```json
{"jsonrpc":"2.0","method":"eth_sendTransaction","params":[{"from":"0xb60e8dd61c5d32be8058bb8eb970870f07233155","to":"0xd46e8dd67c5d32be8058bb8eb970870f07244567","gas":"0x76c0","gasPrice":"0x9184e72a000","value":"0x9184e72a","data":"0xd46e8dd67c5d32be8d46e8dd67c5d32be8058bb8eb970870f072445675058bb8eb970870f072445675"}],"id":1}
```

다행히도 `Web3.js`는 이런 골치 아픈 질의를 몰라도 된다. 편리하고 쉽게 읽을 수 있는 자바스크립트 인터페이스로 상호작용을 하면 되는 것이다.

위의 질의문을 작성할 필요 없이, 코드에서 함수를 호출하는 것은 다음과 같을 것이다 :

```js
CryptoZombies.methods.createRandomZombie("Vitalik Nakamoto 🤔") .send({ from: "0xb60e8dd61c5d32be8058bb8eb970870f07233155", gas: "3000000" })
```

프로젝트의 작업 흐름에 맞춰, 프로젝트에서 가장 많이 사용하는 패키지 도구를 써서 `Web3.js`를 추가할 수 있다 :

```html
<script language="javascript" type="text/javascript" src="web3.min.js"></script>
```

## **2. Web3 프로바이더(Provider)**

우리의 프로젝트에 `Web3.js`를 넣었으니 이제 이를 초기화하고 블록체인과 대화를 해보도록 하자.

우리가 처음 필요로 하는 것은 `Web3 프로바이더(Provider)`이다.

이더리움은 똑같은 데이터의 복사본을 공유하는 `노드`들로 구성되어 있다. `Web3.js`에서 `Web3 프로바이더`를 설정하는 것은 우리 코드에 읽기와 쓰기를 처리할 때 어떤 노드와 통신을 해야 하는지 설정하는 것이다. 이는 전통적인 웹 앱에서 `API`호출을 위해 원격 웹 서버의 `URL`을 설정하는 것과 같다.

나는 나만의 이더리움 노드를 프로바이더로 운영할 수도 있다. 하지만 내가 편리하게 쓸 수 있는 제 3자 서비스가 있다. 내 `DApp`의 사용자들을 위해 나만의 이더리움 노드를 운영할 필요가 없도록 하기 위해 사용할 수 있는 `Infura`라는 서비스가 있다.

### **Infura**

`Infura`는 빠른 읽기를 위한 캐시 계층을 포함하는 다수의 이더리움 노드를 운영하는 서비스이다. 접근을 위한 `API`를 무료로 사용할 수 있다. `Infura`를 프로바이더로 사용하면, 나만의 이더리움을 설치하고 계속 유지할 필요 없이 이더리움 블록체인과 메세지를 확실히 주고받을 수 있다.

다음과 같이 `Web3`에 나의 `Web3 프로바이더`로 `Infura`를 쓰도록 설정할 수 있다 :

```js
var web3 = new Web3(new Web3.providers.WebsocketProvider("wss://mainnet.infura.io/ws"));
```

하지만 많은 사용자들이 우리의 `DApp`을 사용할 것이기에, 그리고 이 사용자들은 단순히 읽기만 하는 게 아니라 블록체인에 뭔가 쓰기도 할 것이기에 우리는 이 사용자들이 그들의 개인 키로 트랜잭션에 서명을 할 수 있도록 해야 할 것이다.

> 참고 : 이더리움(그리고 일반적인 블록체인)은 트랙잭션에 전자 서명을 하기 위해 공개/개인 키 쌍을 사용한다. 말하자면 전자 서명을 위해 엄청나게 안전한 비밀번호 같은 것이다. 이런 방식으로 내가 만약 블록체인에서 어떤 데이터를 변경하면, 나의 공개 키를 통해 내가 거기 서명을 한 사람이라고 `증명`할 수 있다. 하지만 아무도 내 개인 키를 모르기 때문에 내 트랜잭션을 누구도 위조할 수 없다.

이런 암호학은 복잡하다. 그러니 우리의 앱 프론트엔드에서 사용자들의 개인 키를 관리하려 하는 것은 좋은 생각이 아니다.

그리고 이를 대신 처리해주는 서비스가 이미 있다. 이중 가장 유명한 것은 `메타마스크(Metamask)`이다.

### **메타마스크(Metamask)**

`메타마스크`는 사용자들이 이더리움 계정과 개인 키를 안전하게 관리할 수 있게 해주는 크롬과 파이어폭스의 브라우저 확장 프로그램이다. 그리고 해당 계정들을 써서 `Web3.js`를 사용하는 웹사이트들과 상호작용을 할 수 있도록 해준다. (메타마스크를 설치하면 브라우저에서 `Web3`가 작동하고, 이더리움 블록체인과 통신하는 어떤 웹사이트와도 상호작용을 할 수 있다.)

그리고 누군가가 개발자로서, 사용자들이 웹 브라우저를 써서 웹 사이트를 통해 `DApp`과 상호작용을 하길 원한다면(크립토좀비와 같이), 분명 그는 자기의 `DApp`을 메타마스크와 호환할 수 있게 하고 싶을 것이다.

> 참고 : 메타마스크는 내부적으로 `Infura`의 서버를 `Web3 프로바이더`로 사용한다. 위의 내용처럼 말이다. 하지만 사용자들에게 그들만의 `Web3 프로바이더`를 선택할 수 있는 옵션을 주기도 한다. 즉 메타마스크의  `Web3 프로바이더`를 사용한다면, 사용자에게 선택권을 주는 것이기도 하면서 앱에서 걱정할 거리를 하나 줄일 수 있게 되는 것이다.

### **메타마스크의 Web3 프로바이더 사용하기**

메타마스크는 `web3`라는 전역 자바스크립트 객체를 통해 브라우저에게 `Web3 프로바이더`를 주입한다. 그러니 내 앱에서 `web3`가 존재하는지 확인하고, 만약 존재한다면 `web3.currentProvider`를 프로바이더로서 사용하면 된다.

여기 메타마스크에서 제공하는 템플릿 코드가 있다. 사용자가 메타마스크를 설치했느지 확인하고 설치가 안 된 경우 앱을 사용하려면 메타마스크를 설치해야 한다고 알려준다 :

```js
window.addEventListener('load', function() {
	// Web3가 브라우저에 주입되었느지 확인(Mist/MetaMask)
	if (typeof web3 !== 'undefined') {
		// Mist/MetaMask의 프로바이더 사용
		web3js = new Web3(web3.currentProvider);
	} else {
		// 사용자가 Metamask를 설치하지 않은 경우에 대해 처리
		// 사용자들에게 Metamask를 설치하라는 등의 메세지를 보여줄 것
	}
	// 이제 앱을 시작하고 web3에 자유롭게 접근할 수 있다 :
	startApp()
})
```

나는 내가 만드는 모든 앱에서 이 예제 코드를 사용할 수 있다. 사용자들이 내 앱을 사용하려면 메타마스크를 사용하도록 하기 위해서 말이다.

> 참고 : 메타마스크 말고도 사용자들이 쓸 수 있는 다른 개인 키 관리 프로그램도 있다. `미스트(Mist)` 웹 브라우저 같은 것들이다. 하지만 그것들도 모두 `web3`변수를 주입하는 동일한 형태를 사용한다. 그러니 사용자들이 다른 프로그램을 쓰더라도 여기서 설명하는 방식으로 사용자의 `Web3 프로바이더`를 인식할 수 있을 것이다.

## **3. 컨트랙트와 대화하기**

`Web3.js`가 나의 스마트 컨트랙트와 통신을 하기 위해서는 2가지를 필요로 할 것이다 : `컨트랙트의 주소`와 `ABI`이다.

### **컨트랙트 주소**

스마트 컨트랙트를 모두 작성한 다음, 컴파일한 후 이더리움에 배포할 것이다. 배포는 다음 레슨에서 다룰 것이다. 이는 코드를 작성하는 것과는 꽤나 다른 절차이기 때문에 순서를 바꿔 `Web3.js`를 먼저 다루기로 한 것이다.

컨트랙트를 배포한 후, 해당 컨트랙트는 영원히 존재하는 이더리움 상에서 고정된 주소를 얻을 것이다. `lesson2`를 상기해보면, 이더리움 메인넷에서 크립토키티의 주소는 `0x06012c8cf97BEaD5deAe237070F9587f8E7A266d` 였다.

나의 스마트 컨트랙트와 통신을 하기 위해 배포 후 이 주소를 복사해야 할 것이다.

### **컨트랙트 ABI**

컨트랙트와의 통신을 위해 `Web3.js`에서 필요로 하는 다른 하나는 바로 컨트랙트의 `ABI`이다.

`ABI`는 `Application Binary Interface`의 줄임말이다. 기본적으로 `JSON` 형태로 나의 컨트랙트 메소드를 표현하는 것이다. 나의 컨트랙트가 이해할 수 있도록 하려면 `Web3.js`가 어떤 형태로 함수 호출을 해야 하는지 알려주는 것이다.

이더리움에 배포하기 위해 컨트랙트를 컴파일할 때(lesson7에서 다룰 내용), 솔리디티 컴파일러가 나에게 `ABI`를 줄 것이다. 그러니 컨트랙트 주소와 함께 이를 복사하여 저장해야 한다.

### **`Web3.js` 컨트랙트 인스턴스화하기**

컨트랙트의 주소와 `ABI`를 얻고 나면, 다음과 같이 `Web3`에서 인스턴스화 할 수 있다 :

```js
// myContract 인스턴스화
var myContract = new web3js.eth.Contract(myABI, myContractAddress);
```

## **4. 컨트랙트 함수 호출하기**

컨트랙트의 설정이 끝났으니 이제 우리는 `Web3.js`로 컨트랙트와 통신할 수 있다. `Web3.js`는 컨트랙트의 함수를 호출하기 위해 사용할 수 있는 두 개의  메소드를 가지고 있다. 바로 `call`과 `send`이다.

### **Call**

`call`은 `view`와 `pure` 함수를 위해 사용한다. 로컬 노드에서만 실행하고, 블록체인 트랜잭션을 만들지 않는다.

> 복습 : `view`와 `pure` 함수는 읽기 전용이고 블록체인에서 상태를 변경하지 않는다. 가스를 전혀 소모하지 않고, 메타마스크에서 트랜잭션에 서명하라고 사용자에게 창을 띄우지도 않는다.

`Web3.js`를 사용하여, 다음과 같이 `123`을 매개변수로 `myMethod`라는 이름의 함수를 `call`할 수 있다 :

```js
myContract.methods.myMethod(123).call()
```

### **Send**

`send`는 트랜잭션을 만들고 블록체인 상의 데이터를 변경한다. `view`와 `pure`가 아닌 모든 함수에 대해 `send`를 사용해야 하는 것이다.

> 참고 : 트랜잭션을 `send`하는 것은 사용자에게 가스를 지불하도록 하고, 메타마스크에서 트랜잭션에 서명하고 창을 띄울 것이다. `Web3 프로바이더`로 메타마스크를 사용할 때, `send()`를 호출하면 자동으로 이 모든 것이 이루어지고, 우리의 코드에 어떤 특별한 것도 추가할 필요가 없다.

`Web3.js`를 사용하여, 다음과 같이 `123`을 매개변수로 `myMethod`라는 이름의 함수를 호출하는 트랜잭션을 `send`할 수 있다 :

```js
myContract.method.myMethod(123).send()
```

구문은 `call()`과 거의 똑같다.

### **좀비 데이터 받기**

이제 컨트랙트에서 데이터에 접근하기 위해 `call`을 사용하는 에졔를 살펴볼 것이다.

우리가 좀비 배역을 `public`으로 만들었던 것을 기억하자 :

```sol
Zombie[] public zombies;
```

솔리디티에서 `public`으로 변수를 선언하면 자동으로 같은 이름의 퍼블릭 "getter" 함수를 만들어 낸다. 그러니 `ID 15`인 좀비를 찾길 원한다면, 변수를 함수인 것처럼 호출할 수 있다 : `zombies(15)`

여기에 우리의 프론트엔드에서 좀비 `ID`를 받아 해당 좀비에 대해 컨트랙트에 질의를 보내고, 결과를 반환하는 자바스크립트 함수르 작성하는 방법이 있다 :

> 참고 : 이번 레슨에서 우리가 사용하는 모든 코드 예제들은 콜백 대신 `Promise`를 사용하는 `Web3.js 1.0 버전`을 사용하고 있다. 만약 다른 튜토리얼에서 코드를 복사해온다면 같은 버전을 사용하고 있는지 확인해봐야 한다.

```js
function getZombieDetails(id) {
	return cryptoZombies.methods.zombies(id).call()
}

// 함수를 호출하고 결과를 가지고 무언가를 처리 :
getZombieDetails(15)
.then(function(result) {
	console.log("Zombie 15: " + JSON.stringify(result));
});
```

여기서 일어나고 있는 것들을 알아보도록 하자.

`cryptoZombies.methods.zombies(id).call()`은 `Web3 프로바이더`와 통신하여 우리 컨트랙트의 `Zombie[] public zombies`에서 인덱스가 `id`인 좀비를 반환하도록 할 것이다.

이는 외구 서버로 `API`호출을 하는 것처럼 `비동기`적으로 일어난다는 것을 알아두자. 즉 `Web3`는 여기서 `Promise`를 반환한다.

`Promise`가 만들어지면(이는 `Web3 프로바이더`로부터 응답을 받았다는 것을 의미) 우리 예제 코드는 `then`문장을 실행하고, 여기서 `result`를 콘솔에 로그로 기록한다.

`result`는 다음과 같이 생긴 자바스크립트 객체가 될 것이다 :

```js
{
	"name": "H4XF13LD MORRIS'S COOLER OLDER BROTHER",
	"dna": "1337133713371337",
	"level": "9999",
	"readyTime": "1522498671",
	"winCount": "999999999",
	"lossCount": "0" // Obviously.
}
```

이후 이 겍체를 해석하기 위한 프론트엔드 로직을 만들어 의미 있는 방향으로 이 객체를 프론트엔드에 표시할 것이다.

## **5. 메타마스크 & 계정**

